---

copyright:
  years: 2016, 2019
lastupdated: "2019-04-08"

keywords: run jobs, sequences of stages, job types

subcollection: ContinuousDelivery

---

{:shortdesc: .shortdesc}
{:new_window: target="_blank"}
{:codeblock: .codeblock}
{:pre: .pre}
{:screen: .screen}
{:tip: .tip}
{:note: .note}
{:important: .important}
{:download: .download}


# Delivery Pipeline の概要
{: #deliverypipeline_about}

{{site.data.keyword.contdelivery_full}} には、最小限の人的介入でビルド、テスト、デプロイを反復可能な形で行うための Delivery Pipeline が組み込まれています。 パイプラインでは、一連のステージにより入力内容を取得して、
ビルド、テスト、およびデプロイメントなどのジョブを実行します。
{:shortdesc}

パイプラインを表示、変更、または実行する権限は、パイプラインを所有するツールチェーンのアクセス制御に基づいています。 ツールチェーンのアクセス制御について詳しくは、[リソース・グループ内のツールチェーンへのアクセスの管理](/docs/services/ContinuousDelivery?topic=ContinuousDelivery-toolchains-using#managing_access_resource_groups){: new_window}および[Cloud Foundry の組織内のツールチェーンへのアクセスの管理](/docs/services/ContinuousDelivery?topic=ContinuousDelivery-toolchains-using#managing_access_orgs){: new_window}を参照してください。
{: important}

パイプラインによって提供される各種ジョブ・タイプで実行するスクリプトを指定することによって、ジョブの実行内容を直接制御することができます。 スクリプトは Docker イメージ内で実行されますが、このイメージには {{site.data.keyword.Bluemix_notm}} ランタイムと対話するために必要なツールを含む標準開発ツールが多数含まれています。 標準の Docker イメージの内容について詳しくは、[あらかじめインストールされているリソース](/docs/services/ContinuousDelivery?topic=ContinuousDelivery-deliverypipeline_environment#deliverypipeline_resources){: new_window}を参照してください。 標準イメージでは利用できない開発ツールがジョブに必要である場合や、同じツールの異なるバージョンが必要である場合は、カスタム・イメージを使用することができます。 カスタム・イメージについて詳しくは、[カスタム Docker イメージの操作](/docs/services/ContinuousDelivery?topic=ContinuousDelivery-custom_docker_images#custom_docker_images){: new_window}を参照してください。

パイプラインがスクリプトを実行すると、ジョブが実行されているコンテキストを記述するプロパティーが環境変数を使用してスクリプトに渡されます。 例えば、ステージへの入力であるレポの URL、ステージの名前と実行中のジョブの名前、ジョブ・タイプによって指定されたパラメーターなどが渡されます。 使用可能な環境変数のリストを表示するには、[あらかじめインストールされているリソース](/docs/services/ContinuousDelivery?topic=ContinuousDelivery-deliverypipeline_environment#deliverypipeline_resources)を参照してください。 

プロパティーの定義はパイプライン・レベルとステージ・レベルの両方で行うことができます。 パイプライン・プロパティーは、パイプライン内のすべてのステージとジョブで共有されます。 ステージ・プロパティーは特定のステージに固有で、そのステージのすべてのジョブで共有されます。 プロパティーについて詳しくは、[環境プロパティー (環境変数)](/docs/services/ContinuousDelivery?topic=ContinuousDelivery-deliverypipeline_about#environment_properties) を参照してください。

## ステージ
{: #deliverypipeline_stages}

ステージは、コードのビルド、デプロイ、およびテスト時に、入力内容とジョブを編成します。 ステージは、ソース制御リポジトリーからの入力か、他のステージのビルド・ジョブ (ビルド成果物) からの入力を受け入れます。 SCM リポジトリーの入力内容はリポジトリー内の特定のブランチのコンテンツで、ビルド・ジョブの入力内容はジョブによって作成される成果物です。 最初のステージを作成するときに、**「入力」**タブにはデフォルト設定が指定されています。

ステージが実行されると、ステージの入力内容がステージ内の各ジョブに渡されます。 各ジョブにはクリーンなコンテナーが与えられて、それがジョブの実行場所となります。 そのため、ステージ内のジョブ間で相互に成果物を渡すことはできません。 ジョブ間で成果物を渡すには、ジョブを 2 つのステージに分離し、最初のステージのジョブの出力を 2 番目のステージの入力として使用します。
{: tip}

パイプライン・プロパティーを定義する場合と同様に、特定のステージ内のすべてのジョブで使用するステージ・プロパティーを定義することもできます。 例えば、あるステージのデプロイ・ジョブとテスト・ジョブに URL を渡す `TEST_URL` プロパティーを定義することができます。 デプロイ・ジョブはその URL にデプロイし、テスト・ジョブはその URL で実行中のアプリをテストします。 ステージ・プロパティーは環境変数を使用してジョブ・スクリプトにも渡されます。 同一のプロパティーがパイプライン・レベルとステージ・レベルの両方で定義されている場合、ステージ・プロパティーの値が使用されます。

デフォルトでは、ステージでは、変更がプロジェクトの SCM リポジトリーに送信されるたびに、ビルドとデプロイメントが自動的に実行されます。 ステージとジョブは順次実行され、作業のフロー制御を可能にします。 例えば、デプロイメント・ステージの前にテスト・ステージを配置すること
ができます。 テスト・ステージでテストが失敗した場合には、デプロイメント・ステージは実行されません。

特定のステージの制御を厳しくすることができます。 入力時に変更が発生するたびにステージが実行されないようにするには、機能を無効にすることができます。 **「入力」**タブの「ステージ・トリガー」セクションで、**「このステージが手動で実行されたときにのみジョブを実行」**をクリックします。

![「入力」タブ](images/input_tab_only_execute.png)


### ビルド・ステージ
{: #build_stage}

ビルド・ステージは、成果物のビルド方法を示す**ビルダー・タイプ** を指定します。  

ビルド・ジョブで使用可能なフィールドの多くは、複数のビルダー・タイプ間で共通です。
{: tip}

以下のビルダー・タイプを使用できます。

* **シンプル** - **「シンプル」**ビルダー・タイプを使用するジョブは、現在のステージの入力を変更せずに使用し、将来のステージで使用するためにその入力をアーカイブします。 通常、**「シンプル」**ビルダー・タイプは、ステージの入力が SCM リポジトリーからである場合にのみ役立ちます。
* **Ant** - Apache Ant ファイルを使用してビルド・ジョブを管理する場合に、このビルダー・タイプを使用します。
  * **ビルド・スクリプト** - このビルダー・タイプには、有効なビルド・スクリプトであればどれでも選択できます。 デフォルトでは、このビルダー・タイプは 'ant' に設定されます。
  * **作業ディレクトリー** - スクリプトを実行するディレクトリーを指定します。
  * **ビルド・アーカイブ・ディレクトリー** - 後続のステージで使用するためにジョブの出力をアーカイブするディレクトリーを指定します。
  * **テスト・レポートを使用可能にする** - ビルド・ジョブでテストを実行し、その結果ファイルを JUnit XML 形式で出力するように指定する場合は、このチェック・ボックスにチェック・マークを付けます。 結果ファイルに基づいたレポートが、「ジョブ結果 (Job Results)」ページの「テスト (Tests)」タブに表示されます。 何らかのテストが失敗した場合、そのジョブには失敗のマークが付きます。
  * **コード・カバレッジ・レポートを使用可能にする** - コード・カバレッジ・レポートに使用できるフィールドを追加して表示する場合は、このチェック・ボックスにチェック・マークを付けます。 カバレッジ・ランナー (Istanbul、JaCoCo、Cobertura など)、カバレッジ結果ファイルの場所、およびカバレッジ結果ディレクトリーを、作業ディレクトリーからの相対パスで指定することができます。
* **コンテナー・レジストリー**
* **Gradle (Artifactory、Nexus、または SonarQube)**
* **Grunt**
* **IBM Globalization Pipeline**
* **Maven (Artifactory、Nexus、または SonarQube)**
* **npm (Artifactory または Nexus)**
* **シェル・スクリプト**

### デプロイ・ステージ
デプロイ・ステージでは、ビルド・ステージからの入力を指定します。  デプロイ・ステージのジョブでは、**デプロイヤー・タイプ**を指定します。  以下のデプロイヤー・タイプを使用できます。

1. **Cloud Foundry**
2. **Kubernetes**

## ジョブ
{: #deliverypipeline_jobs}

ジョブは、ステージ内の実行単位です。 ステージには複数のジョブを含めることができ、ステージ内のジョブは順次実行されます。 デフォルトでは、ジョブが失敗すると、ステージ内の以降のジョブは実行されません。

![ステージ内のジョブのビルドとテスト](images/jobs.png)

ジョブは、各パイプラインの実行用に作成された Docker コンテナー内にある、個別の作業ディレクトリーで実行されます。 ジョブが実行される前に、ステージ・レベルで定義された入力データがその作業ディレクトリーに取り込まれます。 例えば、テスト・ジョブとデプロイ・ジョブを含むステージがあるとします。 1 つのジョブで依存関係をインストールすると、その依存関係はもう一方のジョブ
では使用できません。 ただし、ステージの入力で依存関係を使用可能にすると、どちらのジョブでも使用可能となります。

単純タイプのビルド・ジョブを除き、ジョブを構成する際は、ビルド・コマンド、テスト・コマンド、またはデプロイメントの各コマンドを含む UNIX シェル・スクリプトを含めることができます。 ジョブは暫定のコンテナーで実行されるため、複数のジョブが同じステージ
の一部である場合でも、1 つのジョブのアクションが他のジョブの実行環境に影響を与えることはできません。

サンプルのビルドおよびデプロイ・スクリプトは、[https://github.com/open-toolchain/commons](https://github.com/open-toolchain/commons) にあります。

さらに、パイプライン・ジョブは、`sudo` として次のコマンドのみを実行できます。
  * `/usr/sbin/service`
  * `/usr/bin/apt-get`
  * `/usr/bin/apt-key`
  * `/usr/bin/dpkg`
  * `/usr/bin/add-apt-repository`
  * `/opt/IBM/node-v0.10.40-linux-x64/npm`
  * `/opt/IBM/node-v0.12.7-linux-x64/npm`
  * `/opt/IBM/node-v4.2.2-linux-x64/npm`
  * `/usr/bin/Xvfb`
  * `/usr/bin/pip`


ジョブの実行後、そのジョブ用に作成されたコンテナーは破棄されます。 ジョブの実行結果は永続できますが、実行環境は永続しません。

ジョブは最大で 60 分実行することができます。 その限界を超えると、ジョブは失敗します。 ジョブが限界を超える場合は、複数の
ジョブに分割してください。 例えば、1 つのジョブが 3 つのタスクを実行する場合、1 つのタスクが 1 つのジョブとなるように、そのジョブを 3 つのジョブに分割することができます。
{: tip}

ジョブをステージに追加する方法については、[ジョブのステージへの追加](/docs/services/ContinuousDelivery?topic=ContinuousDelivery-deliverypipeline_build_deploy#deliverypipeline_add_job){: new_window}を参照してください。

### ビルド・ジョブ

ビルド・ジョブは、デプロイメントに備えてプロジェクトをコンパイルします。 ビルド・ジョブは、ビルド・アーカイブ・ディレクトリーに送信することができる成果物を生成しますが、デフォルトで成果物はプロジェクトのルート・ディレクトリーに配置されます。

ビルド・ジョブからの入力データを取得するジョブは、ジョブが作成されたのと同じ構造のビルド成果物を参照する必要があります。 例えば、ビルド・ジョブがビルド成果物を `output` ディレクトリーにアーカイブする場合、デプロイ・スクリプトは、プロジェクトのルート・ディレクトリーではなく `output` ディレクトリーを参照して、コンパイルされたプロジェクトをデプロイします。 **「ビルド・アーカイブ・ディレクトリー」**フィールドにディレクトリー名を入力することにより、アーカイブするディレクトリーを指定できます。 このフィールドをブランクにしておくと、ルート・ディレクトリーにアーカイブされます。

**シンプル**・ビルダー・タイプを使用する場合は、コードのコンパイルはビルドは行われません。パッケージ化され、今後のステージで使用できる状態になります。
{: tip}

Cloud Foundry を使用してデプロイするとき、アプリを実行できるようにするための適切な成果物が Cloud Foundry に含まれています。 詳しくは、[cf コマンドを使用してのアプリケーションのデプロイ](/docs/cloud-foundry?topic=cloud-foundry-deploy_apps#deploy_apps)を参照してください。 Cloud Foundry アプリ用パイプラインには、cf コマンドを実行するデプロイ・ステージが含まれています。

Cloud Foundry は、[使用するビルドパックを検出 ![外部リンク・アイコン](../../icons/launch-glyph.svg "外部リンク・アイコン")](http://docs.cloudfoundry.org/buildpacks/detection.html) しようとします。 使用する[ビルドパック](/docs/cloud-foundry-public?topic=cloud-foundry-public-using_buildpacks#using_buildpacks)は、アプリのルート・フォルダー内のマニフェスト・ファイルで指定できます。 ビルドパックは通常、ユーザー提供の成果物を調べることにより、どの依存関係をダウンロードするか、バインド済みサービスと通信するためにアプリケーションをどのように構成するかを判別します。 マニフェスト・ファイルについて詳しくは、[アプリケーション・マニフェスト](/docs/cloud-foundry?topic=cloud-foundry-deploy_apps#appmanifest)を参照してください。

### デプロイ・ジョブ

デプロイ・ジョブは、プロジェクトをアプリとして {{site.data.keyword.Bluemix_notm}} にアップロードし、URL からアクセス可能です。 プロジェクトのデプロイ後は、デプロイされたアプリを {{site.data.keyword.Bluemix_notm}} ダッシュボードで検索することができます。

デプロイ・ジョブは、新規アプリをデプロイすることも、既存アプリを更新することもできます。 Cloud Foundry コマンド・ライン・インターフェースや Web IDE の実行バーなどの別の方法で最初にアプリをデプロイしていても、デプロイ・ジョブを使用してアプリを更新することができます。 デプロイ・ジョブでアプリを更新するには、アプリの名前を使用します。

1 つ以上の地域やサービスにデプロイできます。 例えば、1 つ以上のサービスを使用して、1 つの地域でテストし、複数の地域で実動にデプロイするよう {{site.data.keyword.deliverypipeline}} をセットアップできます。

### テスト・ジョブ
条件を満たすことが必要な場合は、ビルド・ジョブおよびデプロイ・ジョブの前または後にテスト・ジョブを組み込みます。 必要に応じて、テスト・ジョブを単純タイプまた
は複雑タイプにカスタマイズすることができます。 例えば、cURL コマンドを実行して特定の応答を予期することができます。 また、一連の単体テストを実行したり、Sauce Labs などサード・パーティーのテスト・サービスを使用して機能テストを実行したりすることもできます。

テストの結果ファイルが JUnit XML 形式の場合、結果ファイルに基づいたレポートが各テスト結果ページの**「テスト」**タブに表示されます。 テストが不合格の場合は、ジョブも失敗します。

## 環境プロパティー (環境変数)
{: #environment_properties}

事前定義された一式の環境プロパティーは、ジョブの実行環境に関する情報へのアクセスを提供します。 事前定義された環境プロパティーの完全なリストについては、[環境プロパティーとリソース](/docs/services/ContinuousDelivery?topic=ContinuousDelivery-deliverypipeline_environment)を参照してください。

独自の環境プロパティーを定義することも可能です。 例えば、パイプライン内のすべてのスクリプトで {{site.data.keyword.Bluemix_notm}} リソースにアクセスするために使用される API 鍵を渡す `API_KEY` プロパティーを定義することができます。

以下のタイプのプロパティーを追加できます。

* **「テキスト」**: 単一行の値を持つプロパティー・キー。
* **「テキスト域 (Text Area)」**: 複数行の値を持つプロパティー・キー。
* **「セキュア」**: AES-128 暗号化で保護された単一行の値を持つプロパティー・キー。 値はアスタリスクとして表示されます。
* **「プロパティー (Properties)」**: プロジェクトのリポジトリーにあるファイル。 このファイルには、複数のプロパティーを含めることができます。 プロパティーはそれぞれ独自の行で指定されている必要があります。 キー値のペアを区切るには、等号 (=) を使用します。 すべてのストリング値を引用符で囲みます。 例えば、`MY_STRING="SOME STRING VALUE"` のようにします。

パイプライン・ジョブの環境プロパティーを調べるには、ジョブのスクリプトで `env` コマンドを実行します。
{:tip}

### パイプライン・プロパティー
パイプライン・プロパティーを定義するには、「パイプライン」ページのオーバーフロー・メニューから、**「パイプラインの構成」**を選択します。

![パイプラインのオーバーフロー・メニュー](images/OverflowMenu.png)

「パイプライン構成」ページの**「環境プロパティー」**タブから、パイプライン・レベルの環境プロパティーを設定します。

![「パイプライン・プロパティー」ページ](images/PipelineProperties.png)

### ステージ・プロパティー
ステージ・プロパティーを定義するには、「ステージ構成」ページで**「環境プロパティー」**タブをクリックします。

![「ステージ・プロパティー」ページ](images/StageProperties.png)

プロパティーをエクスポートすることによって、同じステージ内のジョブ間で環境プロパティーを受け渡すこともできます。 例えば、次のコマンドを組み込んでおいて、ステージ内の別のジョブで `$API_KEY` プロパティーを使用することができます。`export API_KEY=<insert API key here>`
{:tip}

### 算出 (Computed) プロパティー
ステージを実行中に環境プロパティー値を計算し、`build.properties` ファイルを作成してステージ間で共有できるようにし、次のステージでそのファイルを実行することができます。 例えば、ビルド・ジョブで次のコマンドをビルド・スクリプトに組み込むことができます。

  `echo "IMAGE_NAME=${FULL_REPOSITORY_NAME}" >> $ARCHIVE_DIR/build.properties`

`build.properties` ファイルがある場合は、それを実行することですべてのジョブが開始されます。

## 成果物の作成および使用
{: #artifacts}

ビルド・ジョブは、ユーザー・スクリプトが実行される現在のフォルダー内のコンテンツを自動的に取り出します。  後のデプロイメントで git リポジトリー全体を必要としない場合は、明示的な出力ディレクトリーを構成し、そこに関連成果物をコピーまたは作成することをお勧めします。  ジョブ・スクリプトはビルド結果 (出力ディレクトリー) で実行されます。

Cloud Foundry にデプロイするジョブでは、権限ジョブが実行されているユーザーのプラットフォーム API キー、および成果物をデプロイする地域、組織、スペースを指定する必要があります。 アプリを実行するために追加のサービスが必要な場合は、それらを `manifest.yml` ファイルで指定する必要があります。

{{site.data.keyword.containerlong_notm}} にデプロイされるデプロイ・ジョブを権限ジョブが実行されているユーザーのプラットフォーム API キー、Dockerfile、およびオプションの Helm チャートを指定する必要があります。  

ジョブ・スクリプトは、ジョブがターゲット環境にログインした後に、ターゲット環境に割り当てられたプラットフォーム API キーを使用することで実行されます (それにより、スクリプトで `cf push` コマンドまたは `kubectl` コマンドを実行できます)。

## サンプル・パイプライン
{: #deliverypipeline_example}

サンプル・パイプラインには次の 3 つのステージを含めることができます。

1. アプリのビルド・プロセスをコンパイルして実行するビルド・ステージ。
2. アプリのインスタンスをデプロイして、それに対してテストを実行するテスト・ステージ。
3. テスト済みのアプリの実動インスタンスをデプロイする実動ステージ。

次の概念図に、このパイプラインを示しています。

![パイプライン内のステージとジョブの概念図](images/diagram.jpg)

*3 ステージのパイプラインの概念モデル*

各ステージは、その入力データをリポジトリーとビルド・ジョブから取り出し、ステージ内のジョブは、互いに独立して順次実行されます。 サンプル・パイプラインでは、テスト・ステージと実動ステージの両方がビルド・ステージの出力を入力データとして使用する場合でも、ステージは順次実行されます。

## Cloud Foundry マニフェスト・ファイル
{: #deliverypipeline_manifest}

マニフェスト・ファイルは、`manifest.yml` という名前でプロジェクトのルート・ディレクトリーに格納されます。このファイルは、プロジェクトの {{site.data.keyword.Bluemix_notm}} へのデプロイ方法を制御します。 プロジェクト用のマニフェスト・ファイルの作成について詳しくは、[アプリケーション・マニフェストに関する {{site.data.keyword.Bluemix_notm}} の資料](/docs/cloud-foundry?topic=cloud-foundry-deploy_apps#appmanifest)を参照してください。プロジェクトを {{site.data.keyword.Bluemix_notm}} と統合するには、そのプロジェクトのルート・ディレクトリーにマニフェスト・ファイルが必要です。 ただし、そのファイルの情報に基づいてデプロイする必要はありません。

パイプラインでは、`cf push` コマンド引数を使用して、マニフェスト・ファイルで指定可能なすべての設定を指定できます。 `cf push` コマンド引数は、複数のデプロイメント・ターゲットがあるプロジェクトで有用です。 複数のデプロイ・ジョブがすべてプロジェクト・マニフェスト・ファイルで指定されるルートを使用しようとすると、競合が発生します。

競合を避けるには、`cf push`、続けてホスト名引数、`-n`、およびルート名を使用して、ルートを指定することができます。 個々のステージでデプロイメント・スクリプトを変更することにより、複数のターゲットにデプロイする際のルートの競合を回避できます。

`cf push` コマンド引数を使用するには、デプロイ・ジョブの構成設定を開き、**「デプロイ・スクリプト」**フィールドを変更します。 詳しくは、[Cloud Foundry Push 資料![外部リンク・アイコン](../../icons/launch-glyph.svg "外部リンク・アイコン")](http://docs.cloudfoundry.org/devguide/installcf/whats-new-v6.html#push){: new_window} を参照してください。
